// Code generated by protoc-gen-go. DO NOT EDIT.
// source: xdrive2.proto

/*
Package xdrive is a generated protocol buffer package.

It is generated from these files:
	xdrive2.proto

It has these top-level messages:
	ColumnDesc
	Filter
	CSVSpec
	FileSpec
	StringList
	KeyValue
	KeyValueList
	PathSpec
	OpSpec
	OpStatus
	XCol
	XRowSet
	XMsg
	ReadRequest
	SampleRequest
	DataReply
	XColDataReply
	SizeMetaRequest
	SizeMetaReply
	WriteRequest
	WriteData
	WriteReply
*/
package xdrive

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type SpqType int32

const (
	SpqType_UNKNOWN SpqType = 0
	SpqType_BOOL    SpqType = 1
	SpqType_INT16   SpqType = 2
	SpqType_INT32   SpqType = 3
	SpqType_INT64   SpqType = 4
	SpqType_INT128  SpqType = 5
	SpqType_FLOAT   SpqType = 6
	SpqType_DOUBLE  SpqType = 7
	// BYTEA    = 0x0008;   not supported.
	SpqType_CSTR               SpqType = 9
	SpqType_DEC64              SpqType = 10
	SpqType_DEC128             SpqType = 11
	SpqType_DATE               SpqType = 65539
	SpqType_TIME_MILLIS        SpqType = 131075
	SpqType_TIMESTAMP_MILLIS   SpqType = 196612
	SpqType_TIME_MICROS        SpqType = 262148
	SpqType_TIMESTAMP_MICROS   SpqType = 327684
	SpqType_JSON               SpqType = 393225
	SpqType_NUMERIC            SpqType = 458761
	SpqType_TIMESTAMPTZ_MILLIS SpqType = 524292
	SpqType_TIMESTAMPTZ_MICROS SpqType = 589828
)

var SpqType_name = map[int32]string{
	0:      "UNKNOWN",
	1:      "BOOL",
	2:      "INT16",
	3:      "INT32",
	4:      "INT64",
	5:      "INT128",
	6:      "FLOAT",
	7:      "DOUBLE",
	9:      "CSTR",
	10:     "DEC64",
	11:     "DEC128",
	65539:  "DATE",
	131075: "TIME_MILLIS",
	196612: "TIMESTAMP_MILLIS",
	262148: "TIME_MICROS",
	327684: "TIMESTAMP_MICROS",
	393225: "JSON",
	458761: "NUMERIC",
	524292: "TIMESTAMPTZ_MILLIS",
	589828: "TIMESTAMPTZ_MICROS",
}
var SpqType_value = map[string]int32{
	"UNKNOWN":            0,
	"BOOL":               1,
	"INT16":              2,
	"INT32":              3,
	"INT64":              4,
	"INT128":             5,
	"FLOAT":              6,
	"DOUBLE":             7,
	"CSTR":               9,
	"DEC64":              10,
	"DEC128":             11,
	"DATE":               65539,
	"TIME_MILLIS":        131075,
	"TIMESTAMP_MILLIS":   196612,
	"TIME_MICROS":        262148,
	"TIMESTAMP_MICROS":   327684,
	"JSON":               393225,
	"NUMERIC":            458761,
	"TIMESTAMPTZ_MILLIS": 524292,
	"TIMESTAMPTZ_MICROS": 589828,
}

func (x SpqType) String() string {
	return proto.EnumName(SpqType_name, int32(x))
}
func (SpqType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type XMsg_XMsgFlag int32

const (
	XMsg_EOS      XMsg_XMsgFlag = 0
	XMsg_EOB      XMsg_XMsgFlag = 1
	XMsg_CONTINUE XMsg_XMsgFlag = 2
	XMsg_SYNC     XMsg_XMsgFlag = 1000
	XMsg_BSPSYNC  XMsg_XMsgFlag = 1001
	XMsg_BSPDATA  XMsg_XMsgFlag = 1002
)

var XMsg_XMsgFlag_name = map[int32]string{
	0:    "EOS",
	1:    "EOB",
	2:    "CONTINUE",
	1000: "SYNC",
	1001: "BSPSYNC",
	1002: "BSPDATA",
}
var XMsg_XMsgFlag_value = map[string]int32{
	"EOS":      0,
	"EOB":      1,
	"CONTINUE": 2,
	"SYNC":     1000,
	"BSPSYNC":  1001,
	"BSPDATA":  1002,
}

func (x XMsg_XMsgFlag) String() string {
	return proto.EnumName(XMsg_XMsgFlag_name, int32(x))
}
func (XMsg_XMsgFlag) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0} }

type ColumnDesc struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type int32  `protobuf:"varint,2,opt,name=type" json:"type,omitempty"`
}

func (m *ColumnDesc) Reset()                    { *m = ColumnDesc{} }
func (m *ColumnDesc) String() string            { return proto.CompactTextString(m) }
func (*ColumnDesc) ProtoMessage()               {}
func (*ColumnDesc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ColumnDesc) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ColumnDesc) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type Filter struct {
	Op     string   `protobuf:"bytes,1,opt,name=op" json:"op,omitempty"`
	Column string   `protobuf:"bytes,2,opt,name=column" json:"column,omitempty"`
	Args   []string `protobuf:"bytes,3,rep,name=args" json:"args,omitempty"`
}

func (m *Filter) Reset()                    { *m = Filter{} }
func (m *Filter) String() string            { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()               {}
func (*Filter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Filter) GetOp() string {
	if m != nil {
		return m.Op
	}
	return ""
}

func (m *Filter) GetColumn() string {
	if m != nil {
		return m.Column
	}
	return ""
}

func (m *Filter) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

type CSVSpec struct {
	Delimiter string `protobuf:"bytes,1,opt,name=delimiter" json:"delimiter,omitempty"`
	Nullstr   string `protobuf:"bytes,2,opt,name=nullstr" json:"nullstr,omitempty"`
	Header    bool   `protobuf:"varint,3,opt,name=header" json:"header,omitempty"`
	Quote     string `protobuf:"bytes,4,opt,name=quote" json:"quote,omitempty"`
	Escape    string `protobuf:"bytes,5,opt,name=escape" json:"escape,omitempty"`
}

func (m *CSVSpec) Reset()                    { *m = CSVSpec{} }
func (m *CSVSpec) String() string            { return proto.CompactTextString(m) }
func (*CSVSpec) ProtoMessage()               {}
func (*CSVSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CSVSpec) GetDelimiter() string {
	if m != nil {
		return m.Delimiter
	}
	return ""
}

func (m *CSVSpec) GetNullstr() string {
	if m != nil {
		return m.Nullstr
	}
	return ""
}

func (m *CSVSpec) GetHeader() bool {
	if m != nil {
		return m.Header
	}
	return false
}

func (m *CSVSpec) GetQuote() string {
	if m != nil {
		return m.Quote
	}
	return ""
}

func (m *CSVSpec) GetEscape() string {
	if m != nil {
		return m.Escape
	}
	return ""
}

type FileSpec struct {
	Path    string   `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Format  string   `protobuf:"bytes,2,opt,name=format" json:"format,omitempty"`
	Csvspec *CSVSpec `protobuf:"bytes,3,opt,name=csvspec" json:"csvspec,omitempty"`
}

func (m *FileSpec) Reset()                    { *m = FileSpec{} }
func (m *FileSpec) String() string            { return proto.CompactTextString(m) }
func (*FileSpec) ProtoMessage()               {}
func (*FileSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *FileSpec) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *FileSpec) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *FileSpec) GetCsvspec() *CSVSpec {
	if m != nil {
		return m.Csvspec
	}
	return nil
}

type StringList struct {
	Str []string `protobuf:"bytes,1,rep,name=str" json:"str,omitempty"`
}

func (m *StringList) Reset()                    { *m = StringList{} }
func (m *StringList) String() string            { return proto.CompactTextString(m) }
func (*StringList) ProtoMessage()               {}
func (*StringList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *StringList) GetStr() []string {
	if m != nil {
		return m.Str
	}
	return nil
}

type KeyValue struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *KeyValue) Reset()                    { *m = KeyValue{} }
func (m *KeyValue) String() string            { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()               {}
func (*KeyValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *KeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type KeyValueList struct {
	Kv []*KeyValue `protobuf:"bytes,1,rep,name=kv" json:"kv,omitempty"`
}

func (m *KeyValueList) Reset()                    { *m = KeyValueList{} }
func (m *KeyValueList) String() string            { return proto.CompactTextString(m) }
func (*KeyValueList) ProtoMessage()               {}
func (*KeyValueList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *KeyValueList) GetKv() []*KeyValue {
	if m != nil {
		return m.Kv
	}
	return nil
}

type PathSpec struct {
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *PathSpec) Reset()                    { *m = PathSpec{} }
func (m *PathSpec) String() string            { return proto.CompactTextString(m) }
func (*PathSpec) ProtoMessage()               {}
func (*PathSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PathSpec) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type OpSpec struct {
	Op string `protobuf:"bytes,1,opt,name=op" json:"op,omitempty"`
}

func (m *OpSpec) Reset()                    { *m = OpSpec{} }
func (m *OpSpec) String() string            { return proto.CompactTextString(m) }
func (*OpSpec) ProtoMessage()               {}
func (*OpSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *OpSpec) GetOp() string {
	if m != nil {
		return m.Op
	}
	return ""
}

type OpStatus struct {
	Errcode int32  `protobuf:"varint,1,opt,name=errcode" json:"errcode,omitempty"`
	Errmsg  string `protobuf:"bytes,2,opt,name=errmsg" json:"errmsg,omitempty"`
	Flag    int32  `protobuf:"varint,3,opt,name=flag" json:"flag,omitempty"`
}

func (m *OpStatus) Reset()                    { *m = OpStatus{} }
func (m *OpStatus) String() string            { return proto.CompactTextString(m) }
func (*OpStatus) ProtoMessage()               {}
func (*OpStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *OpStatus) GetErrcode() int32 {
	if m != nil {
		return m.Errcode
	}
	return 0
}

func (m *OpStatus) GetErrmsg() string {
	if m != nil {
		return m.Errmsg
	}
	return ""
}

func (m *OpStatus) GetFlag() int32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

//
// XCol and XRowSet
type XCol struct {
	Colname string    `protobuf:"bytes,1,opt,name=colname" json:"colname,omitempty"`
	Nrow    int32     `protobuf:"varint,2,opt,name=nrow" json:"nrow,omitempty"`
	Nullmap []bool    `protobuf:"varint,3,rep,packed,name=nullmap" json:"nullmap,omitempty"`
	Sdata   []string  `protobuf:"bytes,4,rep,name=sdata" json:"sdata,omitempty"`
	I32Data []int32   `protobuf:"varint,5,rep,packed,name=i32data" json:"i32data,omitempty"`
	I64Data []int64   `protobuf:"varint,6,rep,packed,name=i64data" json:"i64data,omitempty"`
	F32Data []float32 `protobuf:"fixed32,7,rep,packed,name=f32data" json:"f32data,omitempty"`
	F64Data []float64 `protobuf:"fixed64,8,rep,packed,name=f64data" json:"f64data,omitempty"`
}

func (m *XCol) Reset()                    { *m = XCol{} }
func (m *XCol) String() string            { return proto.CompactTextString(m) }
func (*XCol) ProtoMessage()               {}
func (*XCol) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *XCol) GetColname() string {
	if m != nil {
		return m.Colname
	}
	return ""
}

func (m *XCol) GetNrow() int32 {
	if m != nil {
		return m.Nrow
	}
	return 0
}

func (m *XCol) GetNullmap() []bool {
	if m != nil {
		return m.Nullmap
	}
	return nil
}

func (m *XCol) GetSdata() []string {
	if m != nil {
		return m.Sdata
	}
	return nil
}

func (m *XCol) GetI32Data() []int32 {
	if m != nil {
		return m.I32Data
	}
	return nil
}

func (m *XCol) GetI64Data() []int64 {
	if m != nil {
		return m.I64Data
	}
	return nil
}

func (m *XCol) GetF32Data() []float32 {
	if m != nil {
		return m.F32Data
	}
	return nil
}

func (m *XCol) GetF64Data() []float64 {
	if m != nil {
		return m.F64Data
	}
	return nil
}

type XRowSet struct {
	Tag     int32   `protobuf:"varint,1,opt,name=tag" json:"tag,omitempty"`
	Round   int32   `protobuf:"varint,2,opt,name=round" json:"round,omitempty"`
	Columns []*XCol `protobuf:"bytes,3,rep,name=columns" json:"columns,omitempty"`
}

func (m *XRowSet) Reset()                    { *m = XRowSet{} }
func (m *XRowSet) String() string            { return proto.CompactTextString(m) }
func (*XRowSet) ProtoMessage()               {}
func (*XRowSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *XRowSet) GetTag() int32 {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *XRowSet) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *XRowSet) GetColumns() []*XCol {
	if m != nil {
		return m.Columns
	}
	return nil
}

type XMsg struct {
	Name   string        `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Xflag  XMsg_XMsgFlag `protobuf:"varint,2,opt,name=xflag,enum=xdrive.XMsg_XMsgFlag" json:"xflag,omitempty"`
	Code   int32         `protobuf:"varint,3,opt,name=code" json:"code,omitempty"`
	Info   string        `protobuf:"bytes,4,opt,name=info" json:"info,omitempty"`
	Rowset *XRowSet      `protobuf:"bytes,5,opt,name=rowset" json:"rowset,omitempty"`
}

func (m *XMsg) Reset()                    { *m = XMsg{} }
func (m *XMsg) String() string            { return proto.CompactTextString(m) }
func (*XMsg) ProtoMessage()               {}
func (*XMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *XMsg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *XMsg) GetXflag() XMsg_XMsgFlag {
	if m != nil {
		return m.Xflag
	}
	return XMsg_EOS
}

func (m *XMsg) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *XMsg) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

func (m *XMsg) GetRowset() *XRowSet {
	if m != nil {
		return m.Rowset
	}
	return nil
}

//
// Read/Sample: Suppose we read two columns,
//
// dg -> xdrive: OpSpec
// xdrive -> dg: OpStatus
// dg -> xdrive: ReadRequest/SampleRequest
// xdrive -> dg: DataReply/XColDataReply col(page) 1
// xdrive -> dg: DataReply/XColDataReply col(page) 2
// xdrive -> dg: DataReply/XColDataReply col(page) 1
// xdrive -> dg: DataReply/XColDataReply col(page) 2
// ...
// xdrive -> dg: DataReply/XColDataReply col(page) 1
// xdrive -> dg: DataReply/XColDataReply col(page) 2
// xdrive -> dg: DataReply/XColDataReply of 0-byte data.
//
// At anytime, client can send an DataReply/XColDataReply of error.
type ReadRequest struct {
	// Which file(s)
	Filespec *FileSpec `protobuf:"bytes,1,opt,name=filespec" json:"filespec,omitempty"`
	// Table Schema
	Columndesc []*ColumnDesc `protobuf:"bytes,2,rep,name=columndesc" json:"columndesc,omitempty"`
	// Names of required columns
	Columnlist []string `protobuf:"bytes,3,rep,name=columnlist" json:"columnlist,omitempty"`
	// Filters
	Filter []*Filter `protobuf:"bytes,4,rep,name=filter" json:"filter,omitempty"`
	// Fragment
	FragId  int32 `protobuf:"varint,5,opt,name=frag_id,json=fragId" json:"frag_id,omitempty"`
	FragCnt int32 `protobuf:"varint,6,opt,name=frag_cnt,json=fragCnt" json:"frag_cnt,omitempty"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (m *ReadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ReadRequest) GetFilespec() *FileSpec {
	if m != nil {
		return m.Filespec
	}
	return nil
}

func (m *ReadRequest) GetColumndesc() []*ColumnDesc {
	if m != nil {
		return m.Columndesc
	}
	return nil
}

func (m *ReadRequest) GetColumnlist() []string {
	if m != nil {
		return m.Columnlist
	}
	return nil
}

func (m *ReadRequest) GetFilter() []*Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *ReadRequest) GetFragId() int32 {
	if m != nil {
		return m.FragId
	}
	return 0
}

func (m *ReadRequest) GetFragCnt() int32 {
	if m != nil {
		return m.FragCnt
	}
	return 0
}

type SampleRequest struct {
	// Which file(s)
	Filespec *FileSpec `protobuf:"bytes,1,opt,name=filespec" json:"filespec,omitempty"`
	// Table Schema
	Columndesc []*ColumnDesc `protobuf:"bytes,2,rep,name=columndesc" json:"columndesc,omitempty"`
	// Fragment
	FragId  int32 `protobuf:"varint,3,opt,name=frag_id,json=fragId" json:"frag_id,omitempty"`
	FragCnt int32 `protobuf:"varint,4,opt,name=frag_cnt,json=fragCnt" json:"frag_cnt,omitempty"`
	// Sample size
	Nrow int32 `protobuf:"varint,5,opt,name=nrow" json:"nrow,omitempty"`
}

func (m *SampleRequest) Reset()                    { *m = SampleRequest{} }
func (m *SampleRequest) String() string            { return proto.CompactTextString(m) }
func (*SampleRequest) ProtoMessage()               {}
func (*SampleRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *SampleRequest) GetFilespec() *FileSpec {
	if m != nil {
		return m.Filespec
	}
	return nil
}

func (m *SampleRequest) GetColumndesc() []*ColumnDesc {
	if m != nil {
		return m.Columndesc
	}
	return nil
}

func (m *SampleRequest) GetFragId() int32 {
	if m != nil {
		return m.FragId
	}
	return 0
}

func (m *SampleRequest) GetFragCnt() int32 {
	if m != nil {
		return m.FragCnt
	}
	return 0
}

func (m *SampleRequest) GetNrow() int32 {
	if m != nil {
		return m.Nrow
	}
	return 0
}

type DataReply struct {
	Errcode int32  `protobuf:"varint,1,opt,name=errcode" json:"errcode,omitempty"`
	Errmsg  string `protobuf:"bytes,2,opt,name=errmsg" json:"errmsg,omitempty"`
	Data    []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *DataReply) Reset()                    { *m = DataReply{} }
func (m *DataReply) String() string            { return proto.CompactTextString(m) }
func (*DataReply) ProtoMessage()               {}
func (*DataReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *DataReply) GetErrcode() int32 {
	if m != nil {
		return m.Errcode
	}
	return 0
}

func (m *DataReply) GetErrmsg() string {
	if m != nil {
		return m.Errmsg
	}
	return ""
}

func (m *DataReply) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type XColDataReply struct {
	Errcode int32  `protobuf:"varint,1,opt,name=errcode" json:"errcode,omitempty"`
	Errmsg  string `protobuf:"bytes,2,opt,name=errmsg" json:"errmsg,omitempty"`
	Data    *XCol  `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
}

func (m *XColDataReply) Reset()                    { *m = XColDataReply{} }
func (m *XColDataReply) String() string            { return proto.CompactTextString(m) }
func (*XColDataReply) ProtoMessage()               {}
func (*XColDataReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *XColDataReply) GetErrcode() int32 {
	if m != nil {
		return m.Errcode
	}
	return 0
}

func (m *XColDataReply) GetErrmsg() string {
	if m != nil {
		return m.Errmsg
	}
	return ""
}

func (m *XColDataReply) GetData() *XCol {
	if m != nil {
		return m.Data
	}
	return nil
}

//
// SizeMeta
//
// dg -> xdrive: OpSpec
// xdrive -> dg: OpStatus
// dg -> xdrive: SizeMetaRequest
// xdrive -> dg: SizeMetaReply
type SizeMetaRequest struct {
	// Which file(s)
	Filespec *FileSpec `protobuf:"bytes,1,opt,name=filespec" json:"filespec,omitempty"`
	// Table Schema
	Columndesc []*ColumnDesc `protobuf:"bytes,2,rep,name=columndesc" json:"columndesc,omitempty"`
	// Fragment
	FragId  int32 `protobuf:"varint,3,opt,name=frag_id,json=fragId" json:"frag_id,omitempty"`
	FragCnt int32 `protobuf:"varint,4,opt,name=frag_cnt,json=fragCnt" json:"frag_cnt,omitempty"`
}

func (m *SizeMetaRequest) Reset()                    { *m = SizeMetaRequest{} }
func (m *SizeMetaRequest) String() string            { return proto.CompactTextString(m) }
func (*SizeMetaRequest) ProtoMessage()               {}
func (*SizeMetaRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *SizeMetaRequest) GetFilespec() *FileSpec {
	if m != nil {
		return m.Filespec
	}
	return nil
}

func (m *SizeMetaRequest) GetColumndesc() []*ColumnDesc {
	if m != nil {
		return m.Columndesc
	}
	return nil
}

func (m *SizeMetaRequest) GetFragId() int32 {
	if m != nil {
		return m.FragId
	}
	return 0
}

func (m *SizeMetaRequest) GetFragCnt() int32 {
	if m != nil {
		return m.FragCnt
	}
	return 0
}

type SizeMetaReply struct {
	Errcode int32  `protobuf:"varint,1,opt,name=errcode" json:"errcode,omitempty"`
	Errmsg  string `protobuf:"bytes,2,opt,name=errmsg" json:"errmsg,omitempty"`
	Nrow    int64  `protobuf:"varint,3,opt,name=nrow" json:"nrow,omitempty"`
	Nbyte   int64  `protobuf:"varint,4,opt,name=nbyte" json:"nbyte,omitempty"`
}

func (m *SizeMetaReply) Reset()                    { *m = SizeMetaReply{} }
func (m *SizeMetaReply) String() string            { return proto.CompactTextString(m) }
func (*SizeMetaReply) ProtoMessage()               {}
func (*SizeMetaReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *SizeMetaReply) GetErrcode() int32 {
	if m != nil {
		return m.Errcode
	}
	return 0
}

func (m *SizeMetaReply) GetErrmsg() string {
	if m != nil {
		return m.Errmsg
	}
	return ""
}

func (m *SizeMetaReply) GetNrow() int64 {
	if m != nil {
		return m.Nrow
	}
	return 0
}

func (m *SizeMetaReply) GetNbyte() int64 {
	if m != nil {
		return m.Nbyte
	}
	return 0
}

//
// Write: Again, suppose we are writing two columns
//
// dg -> xdrive: OpSpec
// xdrive -> dg: OpStatus
// dg -> xdrive: WriteRequest
// xdrive -> dg: WriteReply
// dg -> xdrive: WriteData/XCol of page(col) 1
// xdrive -> dg: WriteReply
// dg -> xdrive: WriteData/XCol of page(col) 2
// xdrive -> dg: WriteReply
// ...
// ...
// dg -> xdrive: WriteData/XCol of page(col) 1
// xdrive -> dg: WriteReply
// dg -> xdrive: WriteData/XCol of page(col) 2
// xdrive -> dg: WriteReply
// dg -> xdrive: WriteData with 0 byte
// xdrive -> dg: WriteReply
//
// If the final WriteReply has no error then the write succeeded.
type WriteRequest struct {
	Filespec   *FileSpec     `protobuf:"bytes,1,opt,name=filespec" json:"filespec,omitempty"`
	Columndesc []*ColumnDesc `protobuf:"bytes,2,rep,name=columndesc" json:"columndesc,omitempty"`
	FragId     int32         `protobuf:"varint,3,opt,name=frag_id,json=fragId" json:"frag_id,omitempty"`
	FragCnt    int32         `protobuf:"varint,4,opt,name=frag_cnt,json=fragCnt" json:"frag_cnt,omitempty"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (m *WriteRequest) String() string            { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *WriteRequest) GetFilespec() *FileSpec {
	if m != nil {
		return m.Filespec
	}
	return nil
}

func (m *WriteRequest) GetColumndesc() []*ColumnDesc {
	if m != nil {
		return m.Columndesc
	}
	return nil
}

func (m *WriteRequest) GetFragId() int32 {
	if m != nil {
		return m.FragId
	}
	return 0
}

func (m *WriteRequest) GetFragCnt() int32 {
	if m != nil {
		return m.FragCnt
	}
	return 0
}

type WriteData struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *WriteData) Reset()                    { *m = WriteData{} }
func (m *WriteData) String() string            { return proto.CompactTextString(m) }
func (*WriteData) ProtoMessage()               {}
func (*WriteData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *WriteData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type WriteReply struct {
	Errcode int32  `protobuf:"varint,1,opt,name=errcode" json:"errcode,omitempty"`
	Errmsg  string `protobuf:"bytes,2,opt,name=errmsg" json:"errmsg,omitempty"`
}

func (m *WriteReply) Reset()                    { *m = WriteReply{} }
func (m *WriteReply) String() string            { return proto.CompactTextString(m) }
func (*WriteReply) ProtoMessage()               {}
func (*WriteReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *WriteReply) GetErrcode() int32 {
	if m != nil {
		return m.Errcode
	}
	return 0
}

func (m *WriteReply) GetErrmsg() string {
	if m != nil {
		return m.Errmsg
	}
	return ""
}

func init() {
	proto.RegisterType((*ColumnDesc)(nil), "xdrive.ColumnDesc")
	proto.RegisterType((*Filter)(nil), "xdrive.Filter")
	proto.RegisterType((*CSVSpec)(nil), "xdrive.CSVSpec")
	proto.RegisterType((*FileSpec)(nil), "xdrive.FileSpec")
	proto.RegisterType((*StringList)(nil), "xdrive.StringList")
	proto.RegisterType((*KeyValue)(nil), "xdrive.KeyValue")
	proto.RegisterType((*KeyValueList)(nil), "xdrive.KeyValueList")
	proto.RegisterType((*PathSpec)(nil), "xdrive.PathSpec")
	proto.RegisterType((*OpSpec)(nil), "xdrive.OpSpec")
	proto.RegisterType((*OpStatus)(nil), "xdrive.OpStatus")
	proto.RegisterType((*XCol)(nil), "xdrive.XCol")
	proto.RegisterType((*XRowSet)(nil), "xdrive.XRowSet")
	proto.RegisterType((*XMsg)(nil), "xdrive.XMsg")
	proto.RegisterType((*ReadRequest)(nil), "xdrive.ReadRequest")
	proto.RegisterType((*SampleRequest)(nil), "xdrive.SampleRequest")
	proto.RegisterType((*DataReply)(nil), "xdrive.DataReply")
	proto.RegisterType((*XColDataReply)(nil), "xdrive.XColDataReply")
	proto.RegisterType((*SizeMetaRequest)(nil), "xdrive.SizeMetaRequest")
	proto.RegisterType((*SizeMetaReply)(nil), "xdrive.SizeMetaReply")
	proto.RegisterType((*WriteRequest)(nil), "xdrive.WriteRequest")
	proto.RegisterType((*WriteData)(nil), "xdrive.WriteData")
	proto.RegisterType((*WriteReply)(nil), "xdrive.WriteReply")
	proto.RegisterEnum("xdrive.SpqType", SpqType_name, SpqType_value)
	proto.RegisterEnum("xdrive.XMsg_XMsgFlag", XMsg_XMsgFlag_name, XMsg_XMsgFlag_value)
}

func init() { proto.RegisterFile("xdrive2.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1115 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xdb, 0x6e, 0xdb, 0x46,
	0x13, 0x0e, 0xc5, 0xa3, 0x46, 0x72, 0xc2, 0x7f, 0x91, 0x3f, 0x65, 0x81, 0x20, 0x15, 0x88, 0x22,
	0x55, 0x0f, 0x30, 0x5a, 0xc5, 0x30, 0x7a, 0x55, 0xc0, 0x96, 0x64, 0x40, 0x8d, 0x0e, 0xce, 0x52,
	0xce, 0xa1, 0x37, 0x01, 0x43, 0xad, 0x14, 0xc2, 0x94, 0x48, 0x93, 0x2b, 0x39, 0xea, 0x95, 0x81,
	0x14, 0x28, 0xf2, 0x1e, 0x05, 0xfa, 0x06, 0x05, 0xfa, 0x0e, 0x7d, 0x90, 0x1e, 0x5e, 0xa2, 0x98,
	0xe5, 0xae, 0xac, 0x3a, 0xc8, 0x8d, 0x0b, 0x14, 0xb9, 0x31, 0xe6, 0x9b, 0x99, 0x9d, 0xc3, 0x37,
	0x33, 0xb4, 0x60, 0xe7, 0xd5, 0x24, 0x8f, 0x57, 0xac, 0xb5, 0x9b, 0xe5, 0x29, 0x4f, 0x89, 0x55,
	0x42, 0x7f, 0x0f, 0xa0, 0x9d, 0x26, 0xcb, 0xf9, 0xa2, 0xc3, 0x8a, 0x88, 0x10, 0x30, 0x16, 0xe1,
	0x9c, 0x79, 0x5a, 0x43, 0x6b, 0x56, 0xa9, 0x90, 0x51, 0xc7, 0xd7, 0x19, 0xf3, 0x2a, 0x0d, 0xad,
	0x69, 0x52, 0x21, 0xfb, 0x1d, 0xb0, 0x8e, 0xe2, 0x84, 0xb3, 0x9c, 0xdc, 0x84, 0x4a, 0x9a, 0x49,
	0xff, 0x4a, 0x9a, 0x91, 0x3b, 0x60, 0x45, 0x22, 0x9e, 0xf0, 0xaf, 0x52, 0x89, 0x30, 0x4a, 0x98,
	0xcf, 0x0a, 0x4f, 0x6f, 0xe8, 0x18, 0x19, 0x65, 0xff, 0x47, 0x0d, 0xec, 0x76, 0xf0, 0x38, 0xc8,
	0x58, 0x44, 0xee, 0x42, 0x75, 0xc2, 0x92, 0x78, 0x1e, 0x73, 0x96, 0xcb, 0x70, 0x97, 0x0a, 0xe2,
	0x81, 0xbd, 0x58, 0x26, 0x49, 0xc1, 0x73, 0x19, 0x56, 0x41, 0xcc, 0xf7, 0x92, 0x85, 0x13, 0x96,
	0x7b, 0x7a, 0x43, 0x6b, 0x3a, 0x54, 0x22, 0x72, 0x1b, 0xcc, 0xb3, 0x65, 0xca, 0x99, 0x67, 0x08,
	0xff, 0x12, 0xa0, 0x37, 0x2b, 0xa2, 0x30, 0x63, 0x9e, 0x59, 0x56, 0x57, 0x22, 0x3f, 0x04, 0xe7,
	0x28, 0x4e, 0x98, 0xa8, 0x84, 0x80, 0x91, 0x85, 0xfc, 0xa5, 0xe2, 0x00, 0x65, 0x7c, 0x37, 0x4d,
	0xf3, 0x79, 0xc8, 0x55, 0x57, 0x25, 0x22, 0x9f, 0x82, 0x1d, 0x15, 0xab, 0x22, 0x63, 0x91, 0x48,
	0x5f, 0x6b, 0xdd, 0xda, 0x2d, 0x79, 0xdd, 0x95, 0x7d, 0x51, 0x65, 0xf7, 0xef, 0x01, 0x04, 0x3c,
	0x8f, 0x17, 0xb3, 0x7e, 0x5c, 0x70, 0xe2, 0x82, 0x8e, 0xcd, 0x68, 0x82, 0x0d, 0x14, 0xfd, 0x16,
	0x38, 0x0f, 0xd9, 0xfa, 0x71, 0x98, 0x2c, 0x19, 0x5a, 0x4f, 0xd9, 0x5a, 0x56, 0x80, 0x22, 0xb6,
	0xb3, 0x42, 0x93, 0xcc, 0x5f, 0x02, 0xff, 0x4b, 0xa8, 0xab, 0x37, 0x22, 0x6a, 0x03, 0x2a, 0xa7,
	0x2b, 0x11, 0xb4, 0xd6, 0x72, 0x55, 0x25, 0xca, 0x83, 0x56, 0x4e, 0x57, 0xfe, 0x3d, 0x70, 0x8e,
	0x43, 0xfe, 0xf2, 0x5d, 0x8d, 0xfa, 0x1e, 0x58, 0xa3, 0x4c, 0x58, 0xaf, 0x0c, 0xd6, 0x3f, 0x06,
	0x67, 0x94, 0x05, 0x3c, 0xe4, 0xcb, 0x02, 0xc7, 0xc1, 0xf2, 0x3c, 0x4a, 0x27, 0xe5, 0xa6, 0x98,
	0x54, 0x41, 0x41, 0x70, 0x9e, 0xcf, 0x8b, 0x99, 0x22, 0xaa, 0x44, 0x98, 0x6b, 0x9a, 0x84, 0x33,
	0xc1, 0x92, 0x49, 0x85, 0xec, 0xff, 0xa6, 0x81, 0xf1, 0xb4, 0x9d, 0x26, 0x18, 0x2e, 0x4a, 0x93,
	0xad, 0xc5, 0x53, 0x50, 0xec, 0x63, 0x9e, 0x9e, 0xab, 0xdd, 0x43, 0x59, 0xed, 0xc2, 0x3c, 0xcc,
	0xc4, 0x32, 0x39, 0x54, 0x41, 0x24, 0xa9, 0x98, 0x84, 0x3c, 0xf4, 0x0c, 0x41, 0x6b, 0x09, 0xd0,
	0x3f, 0x7e, 0xd0, 0x12, 0x7a, 0xb3, 0xa1, 0x63, 0xb1, 0x12, 0x0a, 0xcb, 0xfe, 0x9e, 0xb0, 0x58,
	0x0d, 0xbd, 0xa9, 0x53, 0x05, 0xd1, 0x32, 0x95, 0x6f, 0xec, 0x86, 0xde, 0xac, 0x50, 0x05, 0x85,
	0x45, 0xbe, 0x71, 0x1a, 0x7a, 0x53, 0xa3, 0x0a, 0xfa, 0xcf, 0xc0, 0x7e, 0x4a, 0xd3, 0xf3, 0x80,
	0x89, 0xe9, 0xf2, 0x70, 0x26, 0xb9, 0x41, 0x11, 0x4b, 0xcb, 0xd3, 0xe5, 0x62, 0x22, 0x3b, 0x29,
	0x01, 0xb9, 0x2f, 0x1a, 0x5f, 0xce, 0x17, 0xe5, 0x5d, 0xd4, 0x5a, 0x75, 0x35, 0x34, 0xe4, 0x85,
	0x2a, 0xa3, 0xff, 0x17, 0x32, 0x35, 0x28, 0x69, 0x7c, 0xeb, 0x3e, 0x3f, 0x07, 0xf3, 0x95, 0xe0,
	0x16, 0x43, 0xdf, 0x6c, 0xfd, 0x7f, 0x13, 0x62, 0x50, 0xcc, 0xc4, 0x9f, 0xa3, 0x24, 0x9c, 0xd1,
	0xd2, 0x07, 0x03, 0x88, 0xb1, 0xc9, 0x39, 0x88, 0x99, 0x11, 0x30, 0xe2, 0xc5, 0x34, 0x95, 0x97,
	0x22, 0x64, 0xf2, 0x09, 0x58, 0x79, 0x7a, 0x5e, 0x30, 0x2e, 0x0e, 0x65, 0x6b, 0xaf, 0x65, 0x8b,
	0x54, 0x9a, 0xfd, 0x47, 0xe0, 0xa8, 0x1c, 0xc4, 0x06, 0xbd, 0x3b, 0x0a, 0xdc, 0x1b, 0xa5, 0x70,
	0xe8, 0x6a, 0xa4, 0x0e, 0x4e, 0x7b, 0x34, 0x1c, 0xf7, 0x86, 0x27, 0x5d, 0xb7, 0x42, 0xaa, 0x60,
	0x04, 0xcf, 0x86, 0x6d, 0xf7, 0x77, 0x9b, 0xd4, 0xc1, 0x3e, 0x0c, 0x8e, 0x05, 0xfa, 0x43, 0xa1,
	0xce, 0xc1, 0xf8, 0xc0, 0xfd, 0xd3, 0xc6, 0x6e, 0x6b, 0x94, 0x85, 0x13, 0xca, 0xce, 0x96, 0xac,
	0xe0, 0xe4, 0x0b, 0x70, 0xa6, 0x71, 0xc2, 0xc4, 0x95, 0x69, 0xa2, 0x9a, 0xcd, 0x6e, 0xab, 0xa3,
	0xa5, 0x1b, 0x0f, 0xd2, 0x02, 0x28, 0x69, 0x9b, 0xb0, 0x22, 0xf2, 0x2a, 0x82, 0x56, 0xb2, 0xb9,
	0xca, 0xcd, 0xa7, 0x8e, 0x6e, 0x79, 0x91, 0x7b, 0xea, 0x4d, 0x12, 0x17, 0x5c, 0x7e, 0xa2, 0xb6,
	0x34, 0xe4, 0x3e, 0x58, 0x53, 0xf1, 0xb9, 0x13, 0x9b, 0x55, 0x6b, 0xdd, 0xdc, 0xca, 0xcf, 0x59,
	0x4e, 0xa5, 0x95, 0x7c, 0x00, 0xf6, 0x34, 0x0f, 0x67, 0xcf, 0xe3, 0x89, 0xa0, 0xcd, 0xa4, 0x16,
	0xc2, 0xde, 0x84, 0x7c, 0x08, 0x8e, 0x30, 0x44, 0x0b, 0xee, 0x59, 0xe5, 0xc5, 0x20, 0x6e, 0x2f,
	0xb8, 0xff, 0xab, 0x06, 0x3b, 0x41, 0x38, 0xcf, 0x12, 0xf6, 0xdf, 0xf5, 0xbb, 0x55, 0xa7, 0xfe,
	0xce, 0x3a, 0x8d, 0x7f, 0xd4, 0xb9, 0x39, 0x45, 0xf3, 0xf2, 0x14, 0xfd, 0x47, 0x50, 0xed, 0x84,
	0x3c, 0xa4, 0x2c, 0x4b, 0xd6, 0xd7, 0xfb, 0x28, 0x88, 0x43, 0xc2, 0x1a, 0xea, 0x54, 0xc8, 0x7e,
	0x04, 0x3b, 0xb8, 0xfb, 0xff, 0x26, 0x6c, 0x63, 0x2b, 0xec, 0xd5, 0x93, 0x2a, 0x93, 0xfc, 0xac,
	0xc1, 0xad, 0x20, 0xfe, 0x9e, 0x0d, 0x18, 0x66, 0x79, 0x8f, 0x59, 0xf7, 0x4f, 0x61, 0xe7, 0xb2,
	0xd0, 0x6b, 0xb3, 0x2c, 0x06, 0x87, 0x39, 0x75, 0xf9, 0x0d, 0xbd, 0x0d, 0xe6, 0xe2, 0xc5, 0x5a,
	0xfe, 0x77, 0xd4, 0x69, 0x09, 0xfc, 0x9f, 0x34, 0xa8, 0x3f, 0xc9, 0x63, 0xfe, 0x7e, 0x6f, 0xa2,
	0xff, 0x11, 0x54, 0x45, 0x95, 0xb8, 0x23, 0x9b, 0x1d, 0xd2, 0xb6, 0x76, 0xe8, 0x1b, 0x00, 0xd9,
	0xc6, 0xb5, 0x18, 0xfb, 0xec, 0x97, 0x0a, 0xd8, 0x41, 0x76, 0x36, 0x5e, 0x67, 0x8c, 0xd4, 0xc0,
	0x3e, 0x19, 0x3e, 0x1c, 0x8e, 0x9e, 0x0c, 0xdd, 0x1b, 0xc4, 0x01, 0xe3, 0x70, 0x34, 0xea, 0xbb,
	0x1a, 0xa9, 0x82, 0xd9, 0x1b, 0x8e, 0xbf, 0xda, 0x17, 0x5f, 0x35, 0x14, 0x1f, 0xb4, 0x5c, 0x5d,
	0x8a, 0xfb, 0x7b, 0xae, 0x41, 0x00, 0x2c, 0x74, 0x68, 0x7d, 0xed, 0x9a, 0xa8, 0x3e, 0xea, 0x8f,
	0x0e, 0xc6, 0xae, 0x85, 0xea, 0xce, 0xe8, 0xe4, 0xb0, 0xdf, 0x75, 0x6d, 0x8c, 0xd6, 0x0e, 0xc6,
	0xd4, 0xad, 0xa2, 0x43, 0xa7, 0xdb, 0xde, 0xdf, 0x73, 0x41, 0x38, 0x74, 0xdb, 0xf8, 0xae, 0x46,
	0x00, 0x8c, 0xce, 0xc1, 0xb8, 0xeb, 0xbe, 0xbe, 0x30, 0xc8, 0xff, 0xa0, 0x36, 0xee, 0x0d, 0xba,
	0xcf, 0x07, 0xbd, 0x7e, 0xbf, 0x17, 0xb8, 0xaf, 0x2f, 0x1c, 0x72, 0x07, 0x5c, 0x54, 0x05, 0xe3,
	0x83, 0xc1, 0xb1, 0xd2, 0xff, 0x70, 0x51, 0xdf, 0x72, 0x6d, 0xd3, 0x11, 0xaa, 0xdc, 0xab, 0xae,
	0x52, 0x7f, 0x1b, 0x33, 0x7c, 0x1b, 0x8c, 0x86, 0xee, 0x9b, 0x0b, 0x8f, 0xec, 0x80, 0x3d, 0x3c,
	0x19, 0x74, 0x69, 0xaf, 0xed, 0xbe, 0xb9, 0xb8, 0x4b, 0x3c, 0x20, 0x9b, 0x27, 0xe3, 0xef, 0x2e,
	0xe3, 0x37, 0xde, 0xb6, 0xc8, 0x70, 0x1f, 0x1f, 0x7a, 0x70, 0x27, 0x4a, 0xe7, 0xbb, 0xab, 0x98,
	0xb3, 0xa2, 0x60, 0x38, 0x0b, 0x39, 0xfe, 0x17, 0x96, 0xf8, 0xd5, 0xf9, 0xe0, 0xef, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x32, 0x11, 0xd8, 0x7c, 0x86, 0x0a, 0x00, 0x00,
}
